---
phase: 02-toml-parser
plan: 03
type: tdd
---

<objective>
Implement semantic validation with error accumulation using requirements.java.

Purpose: Validate configuration semantics (Maven version format, required fields, valid scopes) and accumulate ALL errors at once. This is the #1 priority for Phase 2 - users must see all problems in one pass.
Output: ConfigValidator using requirements.java checkIf() for multi-error reporting.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/CONVENTIONS.md
@.planning/phases/02-toml-parser/02-RESEARCH.md
@.planning/phases/02-toml-parser/02-CONTEXT.md
@.planning/phases/02-toml-parser/02-02-SUMMARY.md
@toml/src/main/java/io/github/cowwoc/bill/toml/BillConfig.java
@toml/src/main/java/io/github/cowwoc/bill/toml/BillConfigParser.java

**Tech stack available:**
- requirements.java 12.0 (checkIf().elseGetFailures() for error accumulation)
- BillConfigParser from Plan 2

**Constraining decisions:**
- Error quality is #1 priority - show ALL errors at once (CONTEXT.md)
- Maven version format (not strict SemVer) - accept "1.0", "1.0.0", "21.0", "1.0-SNAPSHOT" etc.
- Valid dependency scopes: compile, test, runtime, provided (Maven standard scopes)

**Requirements.java patterns (CONVENTIONS.md):**
- Import: `import static io.github.cowwoc.requirements12.java.DefaultJavaValidators.*;`
- Error accumulation: `checkIf(value, "name").isNotBlank().and(checkIf(...)).elseGetFailures()`
- Returns List<String> with all validation failures
</context>

<feature>
  <name>Validate BillConfig semantics with error accumulation</name>
  <files>
    toml/src/main/java/io/github/cowwoc/bill/toml/ConfigValidator.java,
    toml/src/test/java/io/github/cowwoc/bill/toml/test/ConfigValidatorTest.java
  </files>
  <behavior>
    Input: BillConfig object
    Output: List<String> of validation errors (empty if valid)

    Validation rules:
    1. project.name must not be blank
    2. project.version must not be blank
    3. project.version must match Maven version pattern (flexible - "1.0", "1.0.0", "1.0-SNAPSHOT", etc.)
    4. Each dependency must have non-blank coordinates and version
    5. Each dependency scope must be one of: compile, test, runtime, provided
    6. build.release (if present) must be valid JDK version number

    Maven version pattern (approximate):
    - One or more version components separated by dots: \d+(\.\d+)*
    - Optional qualifier with dash: (-[a-zA-Z0-9]+)?
    - Examples: "1.0", "21.0", "1.0.0", "1.2.3-SNAPSHOT", "3.2.1.Final"

    Test cases:
    1. Valid config → empty error list
    2. Missing project.name → error "project.name is required and may not be blank"
    3. Missing project.version → error in list
    4. Invalid version format → error in list
    5. Invalid dependency scope → error in list
    6. Multiple violations → ALL errors in list (not just first)
  </behavior>
  <implementation>
    RED phase:
    - Create ConfigValidatorTest with test methods for cases above
    - Tests assert on error list contents using requirements.java
    - Example: requireThat(errors, "errors").isEmpty() for valid config
    - Example: requireThat(errors, "errors").isNotEmpty() and check error messages
    - Tests will fail (ConfigValidator doesn't exist)

    GREEN phase:
    - Create ConfigValidator class
    - Implement validate(BillConfig config) → List<String> method
    - Use requirements.java checkIf() pattern:
      ```java
      List<String> errors = checkIf(config.project().name(), "project.name").isNotBlank()
        .and(checkIf(config.project().version(), "project.version").isNotBlank())
        .and(checkIf(config.project().version(), "project.version").matches(MAVEN_VERSION_PATTERN))
        ... more validations ...
        .elseGetFailures();
      ```
    - Define MAVEN_VERSION_PATTERN as Pattern constant
    - Validate each dependency in loop, accumulate errors
    - Make all tests pass

    REFACTOR phase:
    - Extract helper methods if validation gets complex
    - Improve error messages for clarity
    - Ensure tests still pass

    Integration:
    - Update BillConfigParser to call ConfigValidator after Jackson parsing
    - Throw ConfigParseException with all accumulated errors if validation fails
  </implementation>
</feature>

<verification>
All tests pass:
- mvn test -pl toml succeeds
- Valid configs return empty error list
- Invalid configs return ALL errors at once
- Error messages are clear and helpful
- Maven version pattern accepts valid Maven versions
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- 2-3 atomic commits produced
- ConfigValidator accumulates multiple errors
- Users see ALL problems in one pass (CONTEXT.md priority #1)
</success_criteria>

<output>
After completion, create `.planning/phases/02-toml-parser/02-03-SUMMARY.md` with:
- RED: What validation tests were written
- GREEN: How requirements.java checkIf() was used for error accumulation
- REFACTOR: Any cleanup (error message improvements, etc.)
- Commits: List of commits
- Note: Error quality achievement - multiple errors shown at once
</output>
