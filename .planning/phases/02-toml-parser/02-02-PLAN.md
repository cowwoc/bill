---
phase: 02-toml-parser
plan: 02
type: tdd
---

<objective>
Implement TOML parsing using Test-Driven Development.

Purpose: Parse bill.toml files into BillConfig objects using Jackson 3.0.3 TomlMapper. Drive design through tests to ensure parser handles valid TOML correctly and reports Jackson errors appropriately.
Output: Working BillConfigParser with test coverage for valid/invalid TOML files.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./summary.md
./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/CONVENTIONS.md
@.planning/phases/02-toml-parser/02-RESEARCH.md
@.planning/phases/02-toml-parser/02-CONTEXT.md
@.planning/phases/02-toml-parser/02-01-SUMMARY.md
@toml/src/main/java/io/github/cowwoc/bill/toml/BillConfig.java
@toml/src/main/java/io/github/cowwoc/bill/toml/ProjectInfo.java
@toml/src/main/java/io/github/cowwoc/bill/toml/Dependency.java

**Tech stack available:**
- Jackson 3.0.3 TOML module (tools.jackson.dataformat.toml.TomlMapper)
- requirements.java 12.0 for validation
- BillConfig/ProjectInfo/Dependency POJOs from Plan 1

**Constraining decisions:**
- Error quality is #1 priority (CONTEXT.md)
- Jackson 3.0.x is fail-fast (error collection comes in 3.1) - handle Jackson parse errors gracefully
- bill.toml uses [project] section, dependencies as map with coordinates as keys (CONTEXT.md)

**Key patterns from RESEARCH.md:**
- Use TomlMapper.builder().build() for parser
- Call mapper.readValue(path.toFile(), BillConfig.class)
- Jackson handles type mapping, we'll add semantic validation in Plan 3
</context>

<feature>
  <name>Parse bill.toml into BillConfig</name>
  <files>
    toml/src/main/java/io/github/cowwoc/bill/toml/BillConfigParser.java,
    toml/src/test/java/io/github/cowwoc/bill/toml/test/BillConfigParserTest.java
  </files>
  <behavior>
    Input: Path to bill.toml file
    Output: BillConfig object with parsed values OR exception with helpful message

    Cases:
    1. Valid bill.toml with [project] section → BillConfig with correct values
    2. Valid bill.toml with dependencies → BillConfig with dependency map populated
    3. Valid bill.toml with [build] section → BillConfig with build settings
    4. Minimal bill.toml (just [project] name/version) → BillConfig with defaults
    5. File not found → Exception with clear message
    6. Invalid TOML syntax → Exception wrapping Jackson error
    7. Type mismatch (e.g., version as integer) → Exception with helpful error
  </behavior>
  <implementation>
    RED phase:
    - Create BillConfigParserTest with test methods for cases above
    - Create sample bill.toml test files in src/test/resources/
    - Use requirements.java for test assertions: requireThat(config.project().name(), "name").isEqualTo("expected")
    - Tests will fail (BillConfigParser doesn't exist yet)

    GREEN phase:
    - Create BillConfigParser class with TomlMapper
    - Implement parse(Path) method: mapper.readValue(path.toFile(), BillConfig.class)
    - Wrap Jackson exceptions in ConfigParseException (create simple exception class)
    - Make all tests pass

    REFACTOR phase:
    - Extract error message formatting if needed
    - Clean up exception handling
    - Ensure tests still pass
  </implementation>
</feature>

<verification>
All tests pass:
- mvn test -pl toml succeeds
- Valid TOML files parse correctly
- Invalid TOML produces helpful error messages
- Test coverage includes happy path and error cases
</verification>

<success_criteria>
- Failing test written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor complete if needed
- 2-3 atomic commits produced
- BillConfigParser works for valid/invalid TOML
</success_criteria>

<output>
After completion, create `.planning/phases/02-toml-parser/02-02-SUMMARY.md` with:
- RED: What tests were written, why they failed
- GREEN: What implementation made tests pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of test/feat/refactor commits
</output>
